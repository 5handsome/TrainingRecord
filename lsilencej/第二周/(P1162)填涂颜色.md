- ### 原题：(P1162)[填涂颜色](https://www.luogu.com.cn/problem/P1162)

> # P1162 填涂颜色

## 题目描述

由数字0组成的方阵中，有一任意形状闭合圈，闭合圈由数字1构成，围圈时只走上下左右4个方向。现要求把闭合圈内的所有空间都填写成2.例如：6 × 6的方阵（*n*=6），涂色前和涂色后的方阵如下：

```plain
0 0 0 0 0 0
0 0 1 1 1 1
0 1 1 0 0 1
1 1 0 0 0 1
1 0 0 0 0 1
1 1 1 1 1 1
```
```plain
0 0 0 0 0 0
0 0 1 1 1 1
0 1 1 2 2 1
1 1 2 2 2 1
1 2 2 2 2 1
1 1 1 1 1 1
```

## 输入格式

每组测试数据第一行一个整数*n*(1≤*n*≤30)

接下来*n*行，由0和1组成的*n*×*n*的方阵。

方阵内只有一个闭合圈，圈内至少有一个0。

//感谢黄小U饮品指出本题数据和数据格式不一样. 已修改(输入格式)

## 输出格式

已经填好数字2的完整方阵。

## 输入输出样例

**输入 #1**

```
6
0 0 0 0 0 0
0 0 1 1 1 1
0 1 1 0 0 1
1 1 0 0 0 1
1 0 0 0 0 1
1 1 1 1 1 1
```

**输出 #1**

```
0 0 0 0 0 0
0 0 1 1 1 1
0 1 1 2 2 1
1 1 2 2 2 1
1 2 2 2 2 1
1 1 1 1 1 1
```

## 说明/提示

1≤*n*≤30



- ### 解题思路：

> 题目要将所有被1围住的0变为2，将方阵中的1在vis数组中全设为1，代表为障碍物，分别对每条边进行广搜，若vis数组不为1，则未被访问过也不是障碍物，将其标记为3，这样不停广搜至结束，最后来一次整体遍历，若vis数组为0即是被1围住的0，因为bfs不能进去障碍物里面，将最后一遍遍历中所有的3变为0，将所有的0变为2即为所求



- ### 代码：

~~~cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
#include<cmath>
#include<queue>
#include<stack>
#include<vector>
using namespace std;
struct su {
	int x, y;
};
int n;
int vis[50][50];
int dir[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};// 方向数组，上下左右枚举 
int bfs(int x, int y) {
	if (vis[x][y] == 1) return 0; // 若被访问过直接退出，减少边界处理的时间 
	else {
		queue<su> q;
		su now;
		now.x = x;
		now.y = y;
		q.push(now);
		while (!q.empty()) {
			su pre;
			pre = q.front();
			q.pop();
			for (int i = 0; i < 4; i++) {
				now.x = pre.x + dir[i][0];
				now.y = pre.y + dir[i][1];
				if (now.x >= 1 && now.x <= n && now.y >= 1 && now.y <= n && !vis[now.x][now.y]) { // 边界判断，符合条件则加入队列 
					q.push(now);
					vis[now.x][now.y] = 3; // 标记为3 
				}
			}
		}
		return 0;
	}
}
int main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) scanf("%d", &vis[i][j]);
	for (int i = 1; i <= n; i++) bfs(1, i); // 四条边每个点分别遍历 
	for (int i = 1; i <= n; i++) bfs(i, 1);
	for (int i = 1; i <= n; i++) bfs(i, n);
	for (int i = 1; i <= n; i++) bfs(n, i);
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			if (vis[i][j] == 3) vis[i][j] = 0; // 改回来原来的0 
			else if (!vis[i][j]) vis[i][j] = 2; // 涂色 
		}
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			printf("%d ", vis[i][j]);
		}
		printf("\n");
	}
	return 0;
}
~~~

bfs模板题，要注意边界的处理以及每条边都需要进行遍历，否则会有漏掉的情况出现

