- ### 原题：(HDOJ 1559)[最大子矩阵](http://acm.hdu.edu.cn/showproblem.php?pid=1559)

> # 最大子矩阵
>
> ***Time Limit: 30000/10000 MS (Java/Others)  Memory Limit: 32768/32768 K (Java/Others)
> Total Submission(s): 8095  Accepted Submission(s): 4202***

## Problem Description

给你一个m×n的整数矩阵，在上面找一个x×y的子矩阵，使子矩阵中所有元素的和最大。





## Input

输入数据的第一行为一个正整数T，表示有T组测试数据。每一组测试数据的第一行为四个正整数m,n,x,y（0<m,n<1000 AND 0<x<=m AND 0<y<=n），表示给定的矩形有m行n列。接下来这个矩阵，有m行，每行有n个不大于1000的正整数。





## Output

对于每组数据，输出一个整数，表示子矩阵的最大和。



## Sample Input



> ```
> 1
> 4 5 2 2
> 3 361 649 676 588
> 992 762 156 993 169
> 662 34 638 89 543
> 525 165 254 809 280
> ```



## Sample Output



> ```
> 2474
> ```



- ### 解题思路：

> 用前缀和数组存每一个和，最后根据题目要求的矩阵大小对前缀和数组进行操作即可，用一个变量来计算最大值，用二维前缀和来减少计算次数和时间



- ### 代码：

~~~cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
#include<cmath>
#include<queue>
#include<stack>
#include<vector>
#include<string>
using namespace std;
int ju[1000][1000];
int sum[1000][1000];
int main() {
	int t;
	int m, n, x, y;
	scanf("%d", &t);
	while (t--) {
		memset(ju, 0, sizeof(ju));
		memset(sum, 0, sizeof(sum));
		int maxm = -1, tt;
		scanf("%d%d%d%d", &m, &n, &x, &y);
		for (int i = 1; i <= m; i++) {
			for (int j = 1; j <= n; j++) {
				scanf("%d", &ju[i][j]);
				sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + ju[i][j]; // 构造前缀和数组 
			}
		}
		for (int i = x; i <= m; i++) {
			for (int j = y; j<= n; j++) {
				tt = sum[i][j] - sum[i - x][j] - sum[i][j - y] + sum[i - x][j - y]; // 对前缀和数组进行操作并算出矩阵内的和，注意减去之后要加上对角的值，否则计算的不是矩阵的和，其中有减去的重复部分 
				if (tt > maxm) maxm = tt; // 存每个符合条件的矩阵中的最大值 
			}
		}
		printf("%d\n", maxm);
	}
	return 0;
}
~~~

这是一道考虑对二维前缀和的应用，要注意前缀和操作的部分，最后要加上减去的重复部分

