- ### 原题：(P1605)[迷宫](https://www.luogu.com.cn/problem/P1605)

> # P1605 迷宫

## 题目背景

给定一个N*M方格的迷宫，迷宫里有T处障碍，障碍处不可通过。给定起点坐标和终点坐标，问: 每个方格最多经过1次，有多少种从起点坐标到终点坐标的方案。在迷宫中移动有上下左右四种方式，每次只能移动一个方格。数据保证起点上没有障碍。

## 题目描述

无

## 输入格式

第一行N、M和T，N为行，M为列，T为障碍总数。第二行起点坐标SX,SY，终点坐标FX,FY。接下来T行，每行为障碍点的坐标。

## 输出格式

给定起点坐标和终点坐标，问每个方格最多经过1次，从起点坐标到终点坐标的方案总数。

## 输入输出样例

**输入**

```
2 2 1
1 1 2 2
1 2
```

**输出**

```
1
```

## 说明/提示

【数据规模】

1≤N,M≤5



- ### 解题思路：

> 用一个数组存好起点终点以及障碍物，标记为不能访问，用结构体存每一个坐标，跑一遍dfs，当递归到终点时计数器加一，每访问一个点标记为访问再继续递归，回溯的时候再标记为未访问，最后输出计数器的值即可



- ### 代码：

~~~cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
#include<cmath>
#include<queue>
#include<stack>
using namespace std;
int n, m, cnt;
int vis[10][10];
int dir[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
struct Ge {
	int n, m;
} start, end; // 定义起点和终点存坐标 
int dfs(Ge now, Ge end) {
	if ((now.n == end.n) && (now.m == end.m)) {
		cnt++; // 记录能到达的方法数量 
		return 0;
	}
	for (int i = 0; i <= 3; i++) {
		Ge pre;
		pre.n = now.n + dir[i][0];
		pre.m = now.m + dir[i][1];
		if ((pre.n <= n) && (pre.n >= 1) && (pre.m <= m) && (pre.m >= 1) && !vis[pre.n][pre.m]) {
			vis[pre.n][pre.m] = 1; // 标记为已访问过 
			dfs(pre, end);
			vis[pre.n][pre.m] = 0; // 回溯
		}
	}
	return 0;
}
int main() {
	int t, x, y;
	Ge start, end;
	scanf("%d%d%d", &n, &m, &t);
	scanf("%d%d%d%d", &start.n, &start.m, &end.n, &end.m);
	for (int i = 1; i <= t; i++) {
		scanf("%d%d", &x, &y);
		vis[x][y] = 2; // 障碍物，也可以写1其实 
	}
	vis[start.n][start.m] = 1; // 将起点作为已访问过，不能将终点设为1，否则dfs条件判断进不去 
	dfs(start, end);
	printf("%d", cnt);
	return 0;
}
~~~

搜索中的典型dfs回溯题，可以直接使用一个vis数组进行存起终点障碍以及访问过的点，也可以分两个不同的数组，判断时要注意边界问题以及退出递归的条件

