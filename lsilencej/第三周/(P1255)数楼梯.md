- ### 原题：(P1255)[数楼梯](https://www.luogu.com.cn/problem/P1255)

> # P1255 数楼梯

## 题目描述

楼梯有 *N* 阶，上楼可以一步上一阶，也可以一步上二阶。

编一个程序，计算共有多少种不同的走法。

## 输入格式

一个数字，楼梯数。

## 输出格式

输出走的方式总数。

## 输入输出样例

**输入 #1**

```
4
```

**输出 #1**

```
5
```

## 说明/提示

- 对于 60\%60% 的数据，*N*≤50；
- 对于 100\%100% 的数据，*N*≤5000。



- ### 解题思路：

> 虽是高精度但可以不用字符数组来处理，直接一个二维数组用第二维记录进位数最后倒序输出即可



- ### 代码：

~~~cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
#include<cmath>
#include<queue>
#include<stack>
#include<vector>
#include<string>
#include<set>
using namespace std;
int f[6000][6000], len;
int fb(int n) {
	for (int i = 1; i <= len; i++) f[n][i] = f[n - 1][i] + f[n - 2][i]; // 一维斐波那契递推 
	for (int i = 1; i <= len; i++) {
		if (f[n][i] >= 10) { // 进位处理 
			f[n][i + 1] += f[n][i] / 10; // 第二维用来处理进位 
			f[n][i] %= 10;
		}
		if (f[n][len + 1]) len++; // 位数++ 
	}
}
int main() {
	int n;
	scanf("%d", &n);
	len = 1; // len为记录数字的位数 
	f[1][1] = 1; // 预定义 
	f[2][1] = 2;
	for (int i = 3; i <= n; i++) fb(i);
	for (int i = len; i >= 1; i--) printf("%d", f[n][i]);
	return 0;
}
~~~

巧妙使用二维数组来处理高精问题，避免了字符数组长代码高精，典型的斐波那契数列在高精中的运用