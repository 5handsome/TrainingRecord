- ### 原题：(P3392)[涂国旗](https://www.luogu.com.cn/problem/P3392)

> # P3392 涂国旗

## 题目描述

某国法律规定，只要一个由 *N*×*M* 个小方块组成的旗帜符合如下规则，就是合法的国旗。（毛熊：阿嚏——）

- 从最上方若干行（至少一行）的格子全部是白色的；
- 接下来若干行（至少一行）的格子全部是蓝色的；
- 剩下的行（至少一行）全部是红色的；

现有一个棋盘状的布，分成了 *N* 行 *M* 列的格子，每个格子是白色蓝色红色之一，小 a 希望把这个布改成该国国旗，方法是在一些格子上涂颜料，盖住之前的颜色。

小a很懒，希望涂最少的格子，使这块布成为一个合法的国旗。

## 输入格式

第一行是两个整数 *N*,*M*。

接下来 *N* 行是一个矩阵，矩阵的每一个小方块是`W`（白），`B`（蓝），`R`（红）中的一个。

## 输出格式

一个整数，表示至少需要涂多少块。

## 输入输出样例

**输入 #1**

```
4 5
WRWRW
BWRWB
WRWRW
RWBWR
```

**输出 #1**

```
11
```

## 样例解释

目标状态是：

```plain
WWWWW
BBBBB
RRRRR
RRRRR
```

一共需要改 11 个格子。

## 数据范围

对于 100% 的数据，*N*,*M*≤50。



- ### 解题思路：

> N，M≤50，可用暴力枚举两个边界，分别计算两个边界处于不同位置时的花费，取花费最少即可



- ### 代码：

~~~cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
#include<cmath>
#include<queue>
#include<stack>
#include<vector>
#include<string>
#include<set>
using namespace std;
int main() {
	int n, m, mmin = 999999999;
	char gl[100][100];
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			cin >> gl[i][j]; // 防止每行最后的空格等字符被读入 
		}
	}
	for (int i = 1; i <= n - 2; i++) { // i代表白蓝的分界线 
		for (int j = i + 1; j <= n - 1; j++) { //j代表蓝红的分界线 
			int ans = 0;
			for (int k = 1; k <= i; k++) {
				for (int g = 1; g <= m; g++) {
					if (gl[k][g] != 'W') ans++;
				}
			}
			for (int k = i + 1; k <= j; k++) {
				for (int g = 1; g <= m; g++) {
					if (gl[k][g] != 'B') ans++;
				}
			}
			for (int k = j + 1; k <= n; k++) {
				for (int g = 1; g <= m; g++) {
					if (gl[k][g] != 'R') ans++;
				}
			}
			mmin = min(mmin, ans); // 取最小花费 
		}
	}
	printf("%d", mmin);
	return 0;
}
~~~

疯狂打暴力模拟
