## AcWing 858. Prim算法求最小生成树
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;

const int N = 510;
const int INF = 0x3f3f3f3f;
int g[N][N];
int dist[N];
bool st[N];
int n, m;

int prim()
{
    memset(dist, 0x3f, sizeof(dist));
    
    int res = 0;
    for (int i = 0; i < n; i ++)
    {
        int t = -1;
        for (int j = 1; j <= n; j ++)   //寻点
        {
            if (!st[j] && (t == -1 || dist[j] < dist[t]))
                t = j;
        }
        
        if (i && dist[t] == INF) return INF;    //一定要注意这里, 判断是从第二个点开始的, 不要遗漏这个条件
        if (i) res += dist[t];      //同上
        st[t] = true;
        
        
        for (int j = 1; j <= n; j ++)
        {
            dist[j] = min(dist[j], g[t][j]);    //此处保证虽然dist数组内均为正无穷, 但是会被更新成邻接矩阵中的值
        }
    }
    return res;
}

int main(void)
{
    memset(g, 0x3f, sizeof(g));
    
    cin >> n >> m;
    while (m --)
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        g[a][b] = min(g[a][b], c);      //双向存图
        g[b][a] = min(g[b][a], c);
    }
    
    int t = prim();
    if (t == INF)   puts("impossible");
    else    printf("%d\n", t);
    
    return 0;
}
```

## AcWing 859. Kruskal算法求最小生成树
```cpp
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<cstring>
using namespace std;

const int N = 100010, M = 200010;   //无向图, 边数*2
struct Edge{
    int a, b, w;
    bool operator< (const Edge &W) const    //重载小于号
    {
        return w < W.w;
    }
}edges[M];  //存边方式与bellman_ford类似, 均需要遍历所有边, 因此直接开结构体存边
int n, m;
int p[N];

int find(int x)     //并查集模板
{
    if (p[x] != x)  p[x] = find(p[x]);
    return p[x];
}

int kruskal()
{
    int res = 0, cnt = 0;
    for (int i = 1; i <= n; i ++)    p[i] = i;  //重点重点!! 并查集的初始化!!
    
    for (int i = 0; i < m; i ++)    //kruskal核心部分(利用并查集实现)
    {
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;
        a = find(a), b = find(b);
        if (a != b)
        {
            res += w;
            cnt ++;
            p[a] = b;
        }
    }
    
    if (cnt == n - 1)   return res;
    else    return -1;
}

int main(void)
{
    scanf("%d%d", &n, &m);
    for (int i = 0; i < m; i ++)
    {
        int a, b, w;
        scanf("%d%d%d", &a, &b, &w);
        edges[i] = {a, b, w};
    }
    
    sort(edges, edges + m);     //sort函数使用的是小于号, 因此如果需要重载, 要把小于号重载
    
    int t = kruskal();
    if (t == -1)   puts("impossible");
    else printf("%d\n", t);
    
    return 0;
}
```
## AcWing 860. 染色法判定二分图
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;

const int N = 100010, M = 200010;
int n, m;
int h[N], e[M], ne[M], idx; //无向图, 边数*2
int color[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
}

bool dfs(int u, int c)
{
    color[u] = c;   //给当前点染色
    
    for (int i = h[u]; i != -1; i = ne[i])  //遍历当前点所有出边
    {
        int j = e[i];
        if (!color[j])
        {
            if (!dfs(j, 3 - c)) return false;   //若出边未被染色, 则对该点进行递归判断
        }
        else if (color[j] == c)  return false;  //若出边已经被染色, 则判断是否与该点相同
    }
    
    return true;
}

int main(void)
{
    memset(h, -1, sizeof(h));
    
    cin >> n >> m;
    while (m --)
    {
        int a, b;
        scanf("%d%d", &a, &b);
        add(a, b), add(b, a);
    }
    
    bool flag = true;
    for (int i = 1; i <= n; i ++)   //保证了不是连通图的情况, 所有点可以被遍历
    {
        if (!color[i])
        {
            if (!dfs(i, 1))
            {
                flag = false;
                break;
            }
        }
    }
    
    if (flag)  puts("Yes");
    else    puts("No");
    
    return 0;
}
```

## AcWing 861. 二分图的最大匹配

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;

const int N = 510, M = 100010;

int n1, n2, m;
int h[N], e[M], ne[M], idx;
int match[N];       //记录待匹配部是用谁来匹配的
bool st[N];         //记录每次匹配时已经处理过的带匹配部

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
}

bool find(int x)
{
    for (int i = h[x]; i != -1; i = ne[i])  //遍历它的所有出边, 目的是找到一个可以匹配的点
    {
        int j = e[i];
        if (!st[j])     //若为当前点匹配的操作中, 该点还未被选择过
        {
            st[j] = true;       //则把该点"锁死", 只判断一次这个点可行或不可行
            if (!match[j] || find(match[j]))    //若可行, 则记录匹配信息, 把结果返回
            {
                match[j] = x;   //关键
                return true;
            }                   //若不可行, 则查找下一个点, 该点将不会再进入判断
        }
    }
    return false;
}

int main(void)
{
    cin >> n1 >> n2 >> m;
    
    memset(h, -1, sizeof(h));
    
    while (m --)
    {
        int a, b;
        scanf("%d%d", &a, &b);
        add(a, b);
    }
    
    int res = 0;
    for (int i = 1; i <= n1; i ++)
    {
        memset(st, 0, sizeof(st));  //每一次为待匹配部寻找时, 均需要清空匹配状态(但是保留了匹配结果)
        if (find(i))    res ++;
    }
    
    printf("%d\n", res);
    
    return 0;
}
```

## CODEFORCES 1469D. Ceil Divisions

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;

const int N = 200010;
int a[N];
int n;
int at[5] = {2, 4, 16, 256, 65536};

int main(void)
{
	int t;
	cin >> t;
	while (t --)
	{
		scanf("%d", &n);
		int loc = 4;
		while (n < at[loc])	loc --;
		
		if (n == at[loc])	printf("%d\n", n - 2 + loc);
		else	printf("%d\n", n - 1 + loc);
		
		
		for (int i = 3; i <= n; i ++)
		{
			if (i != 2 && i != 4 && i != 16 && i != 256 && i != 65536 && i != n)
				printf("%d %d\n", i, n);
		}
		
		if (n != at[loc])
		{
			printf("%d %d\n", n, at[loc]);
			printf("%d %d\n", n, at[loc]);
		}
		while (loc)
		{
			printf("%d %d\n", at[loc], at[loc - 1]);
			printf("%d %d\n", at[loc], at[loc - 1]);
			loc --;
		}
	}
	
	return 0;
}
```