## AcWing 831. KMP字符串
### 关键点: next数组的含义:子串中每个位置当不匹配时可以回退到哪个位置
具体为什么可以回退, 就是y总讲的关于前缀后缀相同的问题, 其中i是不动的, 每次只有子串在疯狂与主串进行匹配
### 难点: 如何得到next数组?
是与匹配类似的操作, 相当于拿了一个子串的复印件, 与子串进行匹配. 如果当前位置匹配, 则子串与模板串指针增1, next数组储存下来当前模板串的指针; 
不匹配时, 让模板串的指针回退到上一个与子串相匹配的位置(这样明显前缀与后缀相等的量会减少), 再继续进行匹配. 循环往复, 最终得到next数组.
### 注意的点
1. 子串与next数组需要错位储存, 具体原因是每次用j比较时是错位比较的(```s[i] == p[j + 1]```)
例如: 当我第4位不匹配的时候, 证明我的前三位是匹配的, 那么我需要返回的是前三位匹配时要跳回的地方, 而不是第四位要跳回的地方! 毕竟第四位是不匹配的! 这就是j指针与i指针"错位"的原因
2. 当所储存的模式串和模板串从0开始储存的时候, 同理, 应该在求next数组的时候, 将所求的值存入"下一位置中", 这时next数组的含义就发生了改变, 变成了当我当前位置不匹配时, 我应该跳回哪里; 而不再是与当前位置最长后缀相同的最长前缀在哪.

## AcWing 835. Trie字符串统计
trie树, 即平时所谓的字典树
代码实现还是较为容易的, 难点在于代码和思路结合起来, 其实和之前一样, 基本难得地方就是几个变量的理解.
最为重要的当然是son数组的理解
1. son数组的列坐标是所要储存的全部字符
2. son数组的横坐标可以理解成预留的空间, 每有一个新的, 还没有连接起来的前缀的字符, 就开辟一片新的空间, 同时把这个字符所在位置用idx来指示, 目的是与cnt数组相互关联, 凭借idx找到cnt数组中的位置, 从而找到该字符串出现次数
3. 举个例子, 当我插入abcd时, 使用了son数组的1,2,3,4行空间; 然后当我插入acd时, 使用了son数组的1,5,6行空间; 最后插入abd时, 使用了son数组的1,2,7行空间

## AcWing 143. 最大异或对
二进制的题都比较不熟悉, 先记住如下几个操作
1. x ^ y 代表x异或y, 也就是二进制位相同为0, 不同为1
2. x & y 代表x与y, 也就是二进制位同时为1时才为1, 否则为0
3. 利用"与"操作的特点, 若我们要取出x的第i位的01值, 需要执行如下操作: `u = x >> i & 1;`

## AcWing 836. 合并集合
核心代码就两行:
```
int find(int x)
{
	if (p[x] != x)	p[x] = find(p[x]);
	return p[x];
}
```

用到的是一个p数组, 用来保存下标结点的根结点(也就是这个下标处于哪个集合当中)
find函数中会判断当前结点的父节点是不是它自己, 如果是就说明当前结点的祖先结点是它本身就直接把它返回, 如果不是, 就将它的父节点修改为其父节点的根结点
这样就把它沿路的所有结点都修改成了相同的根结点



----------
学习了对并查集数目的维护后, 发现在合并时可以用如下代码时程序更加简明
```
            x = find(x), y = find(y);
			if (x != y)
			{
			    p[x] = y;
			}
```
含义就是先把两个数的根结点找到, 如果不相等就让其中一个合并到另一个上, 这样写不容易出问题

## AcWing 837. 连通块中点的数量
对并查集内连通点数量的维护
初始每个点的连通块数量显然为1, 之后在合并的时候采用了先取出二者的根结点, 再进行比较, 如果不相同, 则合并后将二者的数量加在一起, 否则就不会进行这个合并操作
询问时直接输出该节点的根结点内所储存的数量即可

## AcWing 838. 堆排序
堆排序, 也就是之前stl里面接触的优先队列, 算是知道了其内部实现原理, 以及为何时间复杂度为log级别
需要注意的是堆的数据结构是由完全二叉树来实现的, 而在表示时是用数组来模拟的, 也就是左儿子是2i, 右儿子是2i+1
本题只需要down操作, 该操作的代码如下
```
void down(int u)
{
	int t = u;
	if (u*2 <= idx && h[u*2] < h[t])	t = u*2;
	if (u*2 + 1 <= idx && h[u*2 + 1] < h[t]) t = u*2 +1;
	if (u != t)
	{
		swap(h[u], h[t]);
		down(t);
	}
}
```
显然这是用递归来实现的, 整个函数的逻辑是, 传入当前要down的坐标位置, 也就是结点位置, 用t来保存他, 然后进行两次判断:
1. 左儿子是否存在(u\*2<=size), 且左儿子是否小于当前结点(h[u\*2] < h[t])
2. 左儿子是否存在(u\*2+1<=size), 且左儿子是否小于当前结点(h[u\*2+1] < h[t])

之后判断t和u是否相等, 也就是我的t是否进行了与最小值的交换, 如果交换了, 把两个坐标内所储存的数进行交换, 然后再对当前的t进行新的一轮down操作(递归实现)

## AcWing 839. 模拟堆
数组实现堆的全部操作(基本)
由于要修改或者删除第k个插入的点, 所以需要两个辅助数组hp[]和ph[](heap_to_point, point_to_heap), 含义如上所示
每次插入一个新的结点, 就使用当前次插入数的下标来储存结点位置, 再把结点位置和插入数联系起来. 重点还是在于up和down操作的实现上

## AcWing 840. 模拟散列表
类似于链表, 更准确的说是类似于邻接表
首先求得一个最大询问次数次的素数, 然后创建一个这么大的头结点数组, 元素数组, next数组
每次插入一个x的值, 就找到对应模除N的正数, 将其插入对应的头结点处, 实现方法与链表类似
寻找时就直接从模除的位置开始遍历这个链表, 直到得到-1或找到这个元素后返回
需要注意的点仍然是: e数组和next数组内元素的储存是不连续的, 要把他们看成是一块可以存放新结点的区域, 当我们需要申请新结点时, 就使用他们区域中的下一块位置即可

## AcWing 841. 字符串哈希
又叫字符串前缀哈希, 原理是把输入的字符串每一位的_(前缀和)_保存下来, 把它看做一个p进制(p一般取131, 13331)的数, 每次想求l到r的字符串时, 只需要`h[r] - h[l - 1] * p[r - l + 1]`即可,
注意几点
1. 所求的方法类似于前缀和, 只需要注意额外乘的P(表示进制)即可
2. h数组和p数组类型取成unsigned long long , 这样当溢出时就相当于对2^64取余了
3. 注意p[0] = 1 的初始化
4. h数组中的元素值具体是多少不重要, 只需要注意让其不为0即可, 这样最后比对两处字符的哈希值即可判断这两个字符串是否相等
