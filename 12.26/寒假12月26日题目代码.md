## AcWing 831. KMP字符串
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<string>
using namespace std;

int n, m;
string p, s;
int ne[100010];

int main(void)
{
	ios::sync_with_stdio(false);
	cin >> n >> p >> m >> s;

	for (int i = 1, j = 0; i < n; i++)
	{
		while (j && p[j] != p[i])	j = ne[j];
		if (p[i] == p[j])
		{
			j++;
		}
		ne[i + 1] = j;
	}

	for (int i = 0, j = 0; i < m; i++)
	{
		while (j && s[i] != p[j])	j = ne[j];
		if (s[i] == p[j])
		{
			j++;
		}
		if (j == n)
		{
			cout << i - j + 1 << " ";
			j = ne[j];
		}
	}
	return 0;
}
```

## AcWing 835. Trie字符串统计
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;

const int N = 100010;
int n, t;
int son[N][26], cnt[N], idx;

char str[N];

void insert(char *str)
{
    int p = 0;
    for (int i = 0; str[i]; i ++)
    {
        int u = str[i] - 'a';
        if (!son[p][u]) son[p][u] = ++ idx;
        p = son[p][u];
    }
    cnt[p] ++;
}

int query(char *str)
{
    int p = 0;
    for (int i = 0; str[i]; i ++)
    {
        int u = str[i] - 'a';
        if (!son[p][u]) return 0;
        p = son[p][u];
    }
    return cnt[p];
}

int main(void)
{
    cin >> t;
    while (t --)
    {
        char c;
        cin >> c;
        if (c == 'I')
        {
            cin >> str;
            insert(str);
        }
        else
        {
            cin >> str;
            cout << query(str) << endl;
        }
    }
    return 0;
}
```
## AcWing 143. 最大异或对
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;

const int N = 100010, M = 30*N;
int son[M][2], cnt[M], idx;
int n, a[N];

void insert(int x)
{
	int p = 0;
	for (int i = 30; i >= 0; i --)
	{
		int u = x >> i & 1;
		if (!son[p][u])	son[p][u] = ++ idx;
		p = son[p][u];
	}
}

int query(int x)
{
	int p = 0, res = 0;
	for (int i = 30; i >= 0; i --)
	{
		int u = x >> i & 1;
		if (son[p][!u])
		{
			p = son[p][!u];
			res = res * 2 + !u;
		}
		else
		{
			p = son[p][u];
			res = res * 2 + u;
		}
	}
	return res;
}

int main(void)
{
	cin >> n;
	for (int i = 0; i < n; i ++)	scanf("%d", &a[i]);
	
	int res = 0;
	for (int i = 0; i < n; i ++)
	{
		insert(a[i]);
		int t = query(a[i]);
		res = max(res, a[i] ^ t);
	}
	cout << res << endl;
	return 0;
}
```

## AcWing 836. 合并集合

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;

int n, m;
const int N = 100010;
int a, b;
char c;
int p[N];

int find(int x)
{
    if (p[x] != x)  p[x] = find(p[x]);
    return p[x];
}

int main(void)
{
    cin >> n >> m;
    for (int i = 1; i <= n; i ++)   p[i] = i;
    
    while (m --)
    {
        cin >> c >> a >> b;
        if (c == 'M')
        {
            p[find(a)] = find(b);
        }
        else
        {
            if (find(a) == find(b)) cout << "Yes" << endl;
            else    cout << "No" << endl;
        }
        
    }
    return 0;
}
```

## AcWing 837. 连通块中点的数量

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<string>
using namespace std;

int n, m;
string c;
const int N = 100010;
int p[N], cnt[N];

int find(int x)
{
	if (p[x] != x)	p[x] = find(p[x]);
	return p[x];
}

int main(void)
{
	cin >> n >> m;
	for (int i = 1; i <= n; i ++)
	{
		p[i] = i;
		cnt[i] ++; 
	} 
	while (m --)
	{
		int x, y;
		cin >> c;
		if (c == "C")
		{
			cin >> x >> y;
			x = find(x), y = find(y);
			if (x != y)
			{
				p[x] = y;
				cnt[y] += cnt[x];
			}
		}
		else if (c == "Q1")
		{
			cin >> x >> y;
			if (find(x) == find(y))
				cout << "Yes" << endl;
			else
				cout << "No" << endl;
		}
		else
		{
			cin >> x;
			cout << cnt[find(x)] << endl;
		}
	}
	return 0;
}
```

## AcWing 838. 堆排序
```cpp
#include<cstdio>
#include<algorithm>
#include<iostream>
using namespace std;

int n, m;
const int N = 100010;
int h[N], idx;

void down(int u)
{
	int t = u;
	if (u*2 <= idx && h[u*2] < h[t])	t = u*2;
	if (u*2 + 1 <= idx && h[u*2 + 1] < h[t]) t = u*2 +1;
	if (u != t)
	{
		swap(h[u], h[t]);
		down(t);
	}
	
}

int main(void)
{
	cin >> n >> m;
	for (int i = 1; i <= n; i ++)
	{
		cin >> h[i];
	}
	idx = n;
	
	for (int i = n / 2; i; i --)
	{
		down(i);
	}
	
	while (m --)
	{
		cout << h[1] << " ";
		h[1] = h[idx --];
		down(1);
	}
	return 0;
}
```
## AcWing 839. 模拟堆
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<string>
using namespace std;

const int N = 100010;
int n;
int h[N], hp[N], ph[N], idx, cnt;
string s;
int k, x;

void heap_swap(int a, int b)
{
    swap(ph[hp[a]], ph[hp[b]]);
    swap(hp[a], hp[b]);
    swap(h[a], h[b]);
}

void up(int u)
{
    while (u/2 && h[u/2] > h[u])
    {
        heap_swap(u/2, u);
        u /= 2;
    }
}

void down(int u)
{
    int t = u;
    if (u*2 <= idx && h[u*2] < h[t])    t = u*2;
    if (u*2 + 1 <= idx && h[u*2 + 1] < h[t])    t = u*2 + 1;
    if (u != t)
    {
        heap_swap(u, t);
        down(t);
    }
}

int main(void)
{
    cin >> n;
    while ( n --)
    {
        cin >> s;
        if (s == "I")
        {
            cin >> x;
            h[++ idx] = x;
            ph[++ cnt] = idx, hp[idx] = cnt;
            up(idx);
        }
        else if(s == "PM")
        {
            cout << h[1] << endl;
        }
        else if (s == "DM")
        {
            heap_swap(1, idx);
            idx --;
            down(1);
        }
        else if (s == "D")
        {
            cin >> k;
            k = ph[k];
            heap_swap(k, idx);
            idx --;
            up(k), down(k);
        }
        else
        {
            cin >> k >> x;
            k = ph[k];
            h[k] = x;
            up(k), down(k);
        }
    }
    return 0;
}
```


## AcWing 840. 模拟散列表
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;

int n;
const int N = 100003;
int h[N], e[N], ne[N], idx;

void insert(int x)
{
	int k = (x % N + N) % N;
	e[idx] = x;
	ne[idx] = h[k];
	h[k] = idx ++;
}

bool find(int x)
{
	int k = (x % N + N) % N;
	for (int i = h[k]; i != -1; i = ne[i])
		if (e[i] == x)
			return true;
	return false;
}

int main(void)
{
	scanf("%d", &n);
	memset(h, -1, sizeof(h));
	
	while (n --)
	{
		char op[2];
		int x;
		scanf("%s%d", op, &x);
		
		if (op[0] == 'I')	insert(x);
		else
		{
			if (find(x))	puts("Yes");
			else puts("No");
		}
	}
	
	return 0;
}
```
## AcWing 841. 字符串哈希
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;

typedef unsigned long long ull;

int n, m;
const int P = 131, N = 100010;
ull h[N], p[N];
char str[N];

ull get(int l, int r)
{
    return h[r] - h[l - 1] * p[r - l + 1];
}

int main(void)
{
    cin >> n >> m;
    scanf("%s", str + 1);
    p[0] = 1;
    for (int i = 1; i <= n; i ++)
    {
        p[i] = p[i - 1] * P;
        h[i] = h[i - 1] * P + str[i];
    }
    
    while (m --)
    {
        int l1, r1, l2, r2;
        scanf("%d%d%d%d", &l1, &r1, &l2, &r2);
        if (get(l1,r1) == get(l2, r2))  puts("Yes");
        else    puts("No");
    }
    
    return 0;
}
```