## AcWing 842. 排列数字
全排列的又一个思路

每次dfs传递的是当前排到了哪个位置的数字, 当当前位置与n相同时, 输出结果
而递归中只需要判断每个值是否被使用过即可

## AcWing 843. n-皇后问题
另一个搜索方式的代码还不是很理解是如何实现的
这个是很久之前写的一个八皇后的代码, 也算是优化了一波
1. 主对角线和副对角线上的元素分别是x+y 和 y-x+n, 原理用坐标系下的直线即可判断出来
2. 输出直接在dfs中完成
3. 每次从0开始递归, 达到n时代表前n-1行已经全部填满, 也就是结果可以得到了
4. 直接在map上进行修改, 同时由于深搜是遍历了所有结果, 所以不需要额外的vis数组

## AcWing 844. 走迷宫
一道最基本的bfs走迷宫题, 学习到的几点
1. 队列中可以用pair来储存点的坐标, 这样就不用再单独定义一个结构体了
2. 把vis数组和走出的距离合二为一, 当然如果不是距离, 而是时间相关也可以这样做, 毕竟bfs所求的每一遍就是类似最短的路径(权值为1时)

## AcWing 845. 八数码
思路的话只要读懂题意就没啥说的, 注意的点:
1. 一维和二维坐标的转换
2. 已经走过的状态的储存
3. unordered_map.count()方法用来得到关键字在哈希表中存在多少个, 由此来判断该情况是否已经走过

如果是poj那道需要求路径的题, 其实在映射中把距离变量换成储存的字符串路径即可(但是可能会超时)

## AcWing 846. 树的重心
这里为了便于理解, 在dfs过程当中使用了maxsubtree表示当前结点所有子树的最大值, totalsubtree表示所有子树的和, 
1. 首先树和图的建立和储存是使用邻接表的形式, 邻接表就是之前链表实现的时候, 头结点换成h数组, 来代表多个头结点的位置. 另外之前的哈希表中的拉链法也用到了这种存储结构
2. 重要的在于理解每次递归遍历的过程中, 得到的是子树的大小, 和该节点最大子树的大小, 以此来得到删除该点后连通块中的最大值
3. 注意对h数组的初始化

## AcWing 847. 图中点的层次
在理解了图和树的储存后, 这类题目做得就比较顺手了(其实是bfs比dfs好理解)
当然还是存在一些需要注意的问题
### 1. 初始化!! 初始化!!! 初始化h数组!!!!!!!!!!
2. 注意这种用距离数组来表示当前点是否已经遍历过的方法, 真的很巧妙

## AcWing 848. 有向图的拓扑序列
逻辑屡清, 代码就容易实现了
首先存起来所有点的入度, 将入度为0的点入队, 每次遍历这个点的所有直接后继, 并把二者之间的边删除, 如果其直接后继的入度会变成0, 那么就把这个点入度, 直到整个队列遍历结束, 判断入队的点数是否和总结点数相同, 如果相同代表队列中所存的就是一个完整的拓扑序列, 否则就是有环存在