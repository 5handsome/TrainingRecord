## AcWing 842. 排列数字
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;

const int N = 10;
int a[N], vis[N], n;

void dfs(int u)
{
    if (u == n)
    {
        for (int i = 0; i < n; i ++)
        {
            printf("%d ", a[i]);
        }
        puts("");
    }
    
    for (int i = 1; i <= n; i ++)
    {
        if (!vis[i])
        {
            a[u] = i;
            vis[i] = 1;
            dfs(u + 1);
            vis[i] = 0;
        }
    }
}

int main(void)
{
    cin >> n;
    
    dfs(0);
    
    return 0;
}
```

## AcWing 843. n-皇后问题
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;

int n;
const int N = 10;
bool col[N], dg[N*N], udg[N*N];
char mapp[N][N];

bool check(int r, int c)
{
	if (r >= 0 && r < n && c >= 0 && c < n)
	{
		if (!col[c] && !dg[r + c] && !udg[c - r + n])
			return true;
	}
	return false;
}

void dfs(int r)
{
	if (r == n)
	{
		for (int i = 0; i < n; i ++)
		{
			for (int j = 0; j < n; j ++)	printf("%c", mapp[i][j]);
			puts("");
		}
		puts("");
	}
	
	for (int i = 0; i < n; i ++)
	{
		if (check(r, i))
		{
			col[i] = dg[r + i] = udg[i - r + n] = true;
			mapp[r][i] = 'Q';
			dfs(r + 1);
			mapp[r][i] = '.';
			col[i] = dg[r + i] = udg[i - r + n] = false;
		}
	}
}

int main(void)
{
	cin >> n;
	
	for (int i = 0; i < n; i ++)
		for (int j = 0; j < n; j ++)
			mapp[i][j] = '.';
	
	dfs(0);
	
	return 0;
}
```
## AcWing 844. 走迷宫
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;

typedef pair<int,int> PII;

const int N = 110;
int n, m;
int mapp[N][N];
int d[N][N];
int dirc[5] = {0,1,0,-1,0};

PII q[N*N];

bool check(int x, int y)
{
	if (x > 0 && x <= n && y > 0 && y <= m)
	{
		if (!mapp[x][y] && d[x][y] == -1)
			return true;
	}
	return false;
}

int bfs()
{
	d[1][1] = 0;
	int hh = 0, tt = 0;
	q[0] = {1,1};
	
	while (hh <= tt)
	{
		PII t = q[hh ++];
		for (int i = 0; i < 4; i ++)
		{
			int tx = t.first + dirc[i];
			int ty = t.second + dirc[i + 1];
			
			if (check(tx, ty))
			{
				d[tx][ty] = d[t.first][t.second] + 1;
				q[++ tt] = {tx, ty};
			}
		}
	}
	return d[n][m];
}

int main(void)
{
	memset(d, -1, sizeof(d));
	
	cin >> n >> m;
	for (int i = 1; i <= n; i ++)
		for (int j = 1; j <= m; j ++)
			cin >> mapp[i][j];
	
	cout << bfs() << endl;
	
	return 0;
}
```

## AcWing 845. 八数码

```cpp
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<cstring>
#include<string>
#include<unordered_map>
#include<queue>
using namespace std;

string start;
string endd = "12345678x";
unordered_map<string, int> um;
int dirc[5] = {0,-1,0,1,0};

bool check(int x, int y)
{
	if (x >= 0 && x < 3 && y >= 0 && y < 3)	return true;
	else	return false;
}

int bfs()
{
	queue<string> q;
	q.push(start);
	um[start] = 0;
	
	while(!q.empty())
	{
		string nows = q.front();
		q.pop();
		
		if (nows == endd)
		{
			return um[nows];
		}
		
		int xloc;
		for (int i = 0; i < 9; i ++)
		{
			if (nows[i] == 'x')
			{
				xloc = i;
				break;
			}
		}
		
		int yy = xloc % 3;
		int xx = xloc / 3;
		
		for (int i = 0; i < 4; i ++)
		{
			int tx = xx + dirc[i];
			int ty = yy + dirc[i + 1];
			int nowx = tx * 3 + ty;
			
			if (check(tx, ty))
			{
				string ts = nows;
				swap(ts[xloc], ts[nowx]);
				if (!um.count(ts))
				{
					um[ts] = um[nows] + 1;
					q.push(ts);
				}
			}
		}
	}
	
	return -1;
}

int main(void)
{
	for (int i = 1; i <= 9; i ++)
	{
		char c;
		cin >> c;
		start += c;
	}
	
	cout << bfs() << endl;
	
	return 0;
}
```

## AcWing 846. 树的重心

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;

const int N = 100010, M = N * 2;
int n;
int h[N], e[M], ne[M], idx;
int ans = N;
bool st[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
}

int dfs(int u)
{
    st[u] = true;
    
    int maxsubtree = 0, totalsubtree = 0;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (st[j])  continue;
        
        int s = dfs(j);
        maxsubtree = max(maxsubtree, s);
        totalsubtree += s;
    }
    
    int res = max(maxsubtree, n - totalsubtree - 1);
    ans = min(ans, res);
    
    return totalsubtree + 1;
}

int main(void)
{
    memset(h, -1, sizeof(h));
    
    cin >> n;
    for (int i = 1; i <= n - 1; i ++)
    {
        int a, b;
        cin >> a >> b;
        add(a,b), add(b,a);
    }
    
    dfs(1);
    
    cout << ans << endl;
    
    return 0;
}
```

## AcWing 847. 图中点的层次
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;

int n, m;
const int N = 100010, M = N * 2;
int h[N], e[M], ne[M], idx;
int d[N];
int q[N];

void add(int a, int b)
{
	e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
}

int bfs(int u)
{
	int hh = 0, tt = 0;
	q[0] = 1;
	d[0] = 0;
	
	while (hh <= tt)
	{
		int k = q[hh ++];
		for (int i = h[k]; i != -1; i = ne[i])
		{
			int j = e[i];
			if (!d[j])
			{
				d[j] = d[k] + 1;
				q[++ tt] = j;
			}
			
			if (j == n)
			{
				return d[j];
			}
		}
	}
	
	return -1;
}


int main(void)
{
    memset(h, -1, sizeof(h));
	cin >> n >> m;
	while (m --)
	{
		int a, b;
		cin >> a >> b;
		add(a, b);
	}
	
	cout << bfs(1) << endl;
	
	return 0;
}
```
## AcWing 848. 有向图的拓扑序列
```cpp
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<cstring>
using namespace std;

const int N = 100010, M = N * 2;

int n, m;
int h[N], e[M], ne[M], idx;
int d[N];
int q[N];

void add(int a, int b)
{
	e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
}

bool topsort()
{
	int hh = 0, tt = -1;
	
	for (int i = 1; i <= n; i ++)
	{
		if (!d[i])
		{
			q[++ tt] = i;
		}
	}
	
	while (hh <= tt)
	{
		int t = q[hh ++];
		
		for (int i = h[t]; i != -1; i = ne[i])
		{
			int j = e[i];
			if (-- d[j] == 0)
			{
				q[++ tt] = j;
			}
		}
	}
	
	return tt == n - 1; 
}

int main(void)
{
	cin >> n >> m;
	
	memset(h, -1, sizeof(h));
	
	while (m --)
	{
		int a, b;
		cin >> a >> b;
		add(a, b);
		
		d[b] ++;
	}
	
	if (!topsort())	puts("-1");
	else
	{
		for (int i = 0; i < n; i ++)	cout << q[i] << " ";
		puts("");
	}
	
	return 0;
}
```