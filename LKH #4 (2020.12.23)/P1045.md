# 麦森数
> [麦森数](https://www.luogu.com.cn/problem/P1045)  
> 高精乘法尚未优化 有一半测试点超时
````cpp
#include <iostream>
#include <vector>
using namespace std;

class BigNum {
   private:
    static const int numAfterPointOfDivision = 3;

   private:
    vector<int> numArray;
    int pointPos = 0;
    bool negativeStatus = false;

   public:
    BigNum(string numString) {
        try {
            changeToNumArray(numString);
        } catch (invalid_argument err) {
            cout << err.what() << endl;
        }
        removeZero();
    }

    BigNum(const BigNum& copy) {
        numArray = copy.numArray;
        pointPos = copy.pointPos;
        negativeStatus = copy.negativeStatus;
    }

    void operator=(const BigNum& rhs) {
        numArray = rhs.numArray;
        pointPos = rhs.pointPos;
    }

    const BigNum operator+(const BigNum& rhs) {
        if (this->negativeStatus == rhs.negativeStatus)
            return sameSignBigNumPlus(rhs);
        if (this->negativeStatus && !rhs.negativeStatus) {
            BigNum back(rhs);
            return back.sameSignBigNumMinus(*this);
        }
        if (!this->negativeStatus && rhs.negativeStatus)
            return sameSignBigNumMinus(rhs);
    }

    const BigNum operator-(const BigNum& rhs) {
        if (!this->negativeStatus && !rhs.negativeStatus)
            return sameSignBigNumMinus(rhs);
        if (this->negativeStatus && rhs.negativeStatus) {
            BigNum back(rhs);
            return back.sameSignBigNumMinus(*this);
        }
        return sameSignBigNumPlus(rhs);
    }

    const BigNum operator*(const BigNum& rhs) const {
        int lhsLength = this->size();
        int rhsLength = rhs.size();
        BigNum back("0");
        for (int i = 0; i < lhsLength; i++) {
            for (int j = 0; j < rhsLength; j++) {
                try {
                    back.setBit(i + j, this->getBit(i) * rhs.getBit(j) + back.getBit(i + j));
                } catch (invalid_argument err) {
                    cout << err.what() << endl;
                    cout << "pos = " << i + j << " value = "
                         << this->getBit(i) * rhs.getBit(j) + back.getBit(i + j) << endl;
                }
            }
        }
        back.pointPos = this->pointPos + rhs.pointPos;
        back.negativeStatus = !((!this->negativeStatus & !rhs.negativeStatus) |
                                (this->negativeStatus & rhs.negativeStatus));
        back.removeZero();
        return back;
    }

    const BigNum operator/(const BigNum& rhs) {
        // int pointCnt = 0;
        // BigNum ten("10");
        // BigNum one("1");
        // BigNum half("0.5");

        // while (this->size() <= rhs.size() + 2) {
        //     *this = *this * ten;
        //     pointCnt++;
        // }

        // BigNum low(tenPow(this->size() - rhs.size() - 1));
        // BigNum high(tenPow(this->size()));
        // BigNum mid((low + high) * half);
        // BigNum ans = mid * rhs;

        // while (ans.lessCompareTo(*this) && mid.lessCompareTo(high)) {
        //     if (ans.lessCompareTo(*this) == 1)
        //         low = mid + one;
        //     if (ans.lessCompareTo(*this) == -1)
        //         high = mid - one;
        //     mid = (low + high) * half;
        //     ans = mid * rhs;
        //     cout << ans.toString() << endl;
        // }

        // cout << mid.toString() << endl;
        // return mid;
    }

   private:
    int lessCompareTo(const BigNum& rhs) {
        if ((this->operator-(rhs)).toString() == "0")
            return 0;
        if (this->operator-(rhs).negativeStatus)
            return 1;
        if (!this->operator-(rhs).negativeStatus)
            return -1;
    }

    const BigNum sameSignBigNumPlus(const BigNum& rhs) {
        BigNum *back, *small;
        if (this->size() - this->pointPos >= rhs.size() - rhs.pointPos) {
            back = new BigNum(*this);
            small = new BigNum(rhs);
        } else {
            back = new BigNum(rhs);
            small = this;
        }

        if (back->pointPos >= small->pointPos) {
            small->format(back->pointPos);
        } else {
            back->format(small->pointPos);
        }

        int length = small->size();
        while (length--) {
            try {
                back->setBit(length, back->getBit(length) + small->getBit(length));
            } catch (invalid_argument err) {
                cout << err.what() << endl;
            }
        }

        removeZero();
        return *back;
    }

    const BigNum sameSignBigNumMinus(const BigNum& rhs) {
        BigNum *back, *small;
        if (this->size() - this->pointPos >= rhs.size() - rhs.pointPos) {
            back = new BigNum(*this);
            small = new BigNum(rhs);
        } else {
            back = new BigNum(rhs);
            back->negativeStatus = true;
            small = this;
        }

        if (back->pointPos >= small->pointPos) {
            small->format(back->pointPos);
        } else {
            back->format(small->pointPos);
        }

        int length = small->size();
        while (length--) {
            try {
                back->setBit(length, back->getBit(length) - small->getBit(length));
            } catch (invalid_argument err) {
                cout << err.what() << endl;
            }
        }
        back->changeTheHighestBitToPositive();
        back->removeZero();
        return *back;
    }

   public:
    void changeToNumArray(string numString) {
        int length = numString.size();
        bool pointOnceFlag = true;
        bool negativeOnceFlag = true;
        while (length--) {
            char c = numString.at(length);
            if (c >= '0' && c <= '9') {
                numArray.push_back(c - '0');
            } else if (pointOnceFlag && c == '.') {
                pointPos = numString.size() - 1 - length;
                pointOnceFlag = false;
            } else if (negativeOnceFlag && c == '-') {
                negativeStatus = true;
                negativeOnceFlag = false;
            } else {
                throw invalid_argument("creat BigNum is failed, string is valid");
            }
        }
    }

    void setBit(int pos, int value) {
        while (pos > numArray.size() - 1) {
            numArray.push_back(0);
        }

        if (value < 0 && pos + 1 < numArray.size()) {
            setBit(pos + 1, this->getBit(pos + 1) - (-value) / 10 - 1);
            value = 10 - (-value) % 10;
        } else if (value < 0 && pos + 1 == numArray.size()) {
            numArray.push_back(0 - 1 - (-value) / 10);
            value = 10 - (-value) % 10;
        } else if (value < 0 && pos + 1 > numArray.size()) {
            throw invalid_argument("setBit is failed! pos is invalid");
        }

        if (value > 9) {
            setBit(pos + 1, value / 10 + this->getBit(pos + 1));
            value = value % 10;
        }

        numArray[pos] = value;
    }

    int getBit(int pos) const {
        if (pos < 0)
            throw range_error("pos is invalid!");

        if (pos >= numArray.size())
            return 0;

        return numArray[pos];
    }

    int size() const {
        return numArray.size();
    }

    BigNum tenPow(int size) {
        BigNum ten("10");
        BigNum back("1");
        while (size--) {
            back = back * ten;
        }
        return back;
    }

    string subNumArray(int begin, int end) {
        if (begin < 0)
            throw invalid_argument("subNumArray is failed!");

        while (end >= numArray.size()) {
            numArray.insert(numArray.begin(), 0);
            pointPos++;
        }

        string back;
        while (end - begin) {
            back.push_back(numArray[numArray.size() - 1 - begin]);
            begin++;
        }

        return back;
    }

    void addZeroAfterPoint(int num) {
        while (num--) {
            numArray.insert(numArray.begin(), 0);
            pointPos++;
        }
    }

    void removeZero() {
        while (numArray.size() > pointPos + 1 && !numArray.at(numArray.size() - 1)) {
            numArray.erase(numArray.end() - 1);
        }

        while (pointPos && !numArray[0]) {
            numArray.erase(numArray.begin());
            pointPos--;
        }

        if (numArray.size() == 1 && numArray[0] == 0)
            negativeStatus = false;
    }

    void changeTheHighestBitToPositive() {
        if (numArray[numArray.size() - 1] >= 0)
            return;

        BigNum buf(*this);
        buf.numArray[numArray.size() - 1] = 0;

        this->numArray[numArray.size() - 1] = 1;
        *this = sameSignBigNumMinus(buf);
        *this = sameSignBigNumMinus(buf);
        this->negativeStatus = true;
    }

    void format(int bitAfterPoint) {
        while (pointPos < bitAfterPoint) {
            numArray.insert(numArray.begin(), 0);
            pointPos++;
        }

        while (pointPos > bitAfterPoint) {
            numArray.erase(numArray.begin());
            pointPos--;
        }
    }

   public:
    string toString() const {
        string back;
        int length = numArray.size();

        if (length == 0)
            throw runtime_error("No num");

        while (length--) {
            back.push_back(numArray.at(length) + '0');
        }

        if (pointPos) {
            while (pointPos < back.size())

                back.insert(back.end() - pointPos, '.');
        }

        if (negativeStatus)
            back.insert(back.begin(), '-');
        return back;
    }

};

BigNum binaryPow(BigNum a, int b) {
    BigNum res("1");
    while (b) {
        if (b & 1)
            res = res * a;
        a = a * a;
        b >>= 1;
    }
    return res;
}

int main() {
    int num;
    cin >> num;
    BigNum ans = binaryPow(BigNum("2"), num) - BigNum("1");
    string ansStr = ans.toString();
    if (ans.size() > 500)
        ansStr = ansStr.substr(ans.size() - 500, ans.size());
    while (ansStr.length() < 500)
        ansStr.insert(ansStr.begin(), '0');

    cout << ans.size() << '\n';
    int cnt = 0;
    for (int i = 0; i < 10; i++) {
        for (int j = 0; j < 50; j++) {
            cout << ansStr.at(cnt++);
        }
        cout << '\n';
    }
    return 0;
}
````
