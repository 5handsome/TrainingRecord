## AcWing 799. 最长连续不重复子序列
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;

int n;
const int N = 1e5 + 10;
int a[N], s[N];

int main(void)
{
    cin >> n;
    for (int i = 0; i < n; i ++)    scanf("%d", &a[i]);
    
    int res = 0;
    for (int i = 0, j = 0; i < n; i ++)
    {
        s[a[i]] ++;
        while (s[a[i]] > 1)
        {
            s[a[j]] --;
            j ++;
        }
        res = max(res, i - j + 1);
        
    }
    cout << res << endl;
    return 0;
}
```

## AcWing 800. 数组元素的目标和
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;

int n, m, x;
const int N = 1e5 + 10;
int a[N];
int b[N];

int main(void)
{
    cin >> n >> m >> x;
    for (int i = 0; i < n; i ++)    scanf("%d", &a[i]);
    for (int i = 0; i < m; i ++)    scanf("%d", &b[i]);

    for (int i = 0, j = m - 1; i < n; i ++)
    {
        while (a[i] + b[j] > x)
        {
            j --;
        }

        if (a[i] + b[j] == x)
        {
            cout << i << " " <<  j << endl;
            break;
        }

    }
    return 0;
}
```
## AcWing 2816. 判断子序列
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;

const int N = 100010;
int a[N], b[N]; 

int main(void)
{
	int n, m;
	cin >> n >> m;
	for (int i = 0; i < n; i ++)
	{
		scanf("%d", &a[i]);
	}
	for (int j = 0; j < m; j ++)
	{
		scanf("%d", &b[j]);
	}
	
	int j = 0;
	for (int i = 0; i < m; i ++)
	{
		while (j < n && a[j] == b[i])
		{
			i ++;
			j ++;
		}
		if (j == n)	break;
	}
	if (j == n)	cout << "Yes" << endl;
	else	cout << "No" << endl; 
	
	return 0;
}
```

## AcWing 802. 区间和

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;

typedef pair<int,int> PII;

int n, m;
const int N = 3e5 + 10;
int a[N], s[N];

vector<int> alls;
vector<PII> add, query;

int find (int x)
{
	int l = 0, r = alls.size() - 1;
	while (l < r)
	{
		int mid = l + r >> 1;
		if (alls[mid] >= x)	r = mid;
		else	l = mid + 1;
	}
	return r + 1;
}

int main(void)
{
	cin >> n >> m;
	for (int i = 0; i < n; i ++)
	{
		int x, c;
		cin >> x >> c;
		
		add.push_back({x, c});
		alls.push_back(x);
	}
	for (int i = 0; i < m; i ++)
	{
		int l, r;
		cin >> l >> r;
		
		query.push_back({l, r});
		alls.push_back(l);
		alls.push_back(r);
	}
	
	// 去重
	sort(alls.begin(), alls.end());
	alls.erase(unique(alls.begin(), alls.end()), alls.end());	
	// 至此alls中所剩的元素与坐标构成了一一对应的离散化数组
	 
	// 如下执行插入和询问操作
	for (auto item : add)
	{
		int x = find(item.first);
		a[x] += item.second;
	}
	
	for (int i = 1; i <= alls.size(); i ++)	s[i] = s[i - 1] + a[i];
	
	for (auto item : query)
	{
		int l = find(item.first);
		int r = find(item.second);
		
		cout << s[r] - s[l - 1] << endl;
	}
	
	return 0;
}
```

## AcWing 803. 区间合并

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
typedef pair<int,int> PII;

int n;
const int N = 1e5 + 10;
PII a[3*N + 10];

int main(void)
{
	cin >> n;
	for (int i = 0; i < n; i ++)
	{
		int l, r;
		cin >> l >> r;
		a[i].first = l;
		a[i].second = r;
	}
	sort(a, a + n);
	
	int ans = 1;
	int end = a[0].second;
	for (int i = 1; i < n; i ++)
	{
		int l = a[i].first, r = a[i].second;
		if (l <= end)
		{
			if (r > end)	end = r;
		}
		else
		{
			ans ++;
			end = r;
		}
	}
	cout << ans << endl;
	
	return 0;
}
```

## AcWing 826. 单链表
```cpp
#include<cstdio>
#include<algorithm>
#include<iostream>
using namespace std;

int n;
const int N = 100010;
int head, e[N], ne[N], idx;

void init()
{
    head = -1, idx = 0;
}

void insert_to_head(int x)
{
    e[idx] = x;
    ne[idx] = head;
    head = idx ++;
}

void insert(int k, int x)
{
    e[idx] = x;
    ne[idx] = ne[k - 1];
    ne[k - 1] = idx ++;
}

void remove(int k)
{
    ne[k - 1] = ne[ne[k - 1]];
}

int main(void)
{
    int k, x;
    char c;
    
    init();
    cin >> n;
    while (n --)
    {
        cin >> c;
        if (c == 'H')
        {
            cin >> x;
            insert_to_head(x);
        }
        else if (c == 'I')
        {
            cin >> k >> x;
            insert(k, x);
        }
        else
        {
            cin >> k;
            if (k == 0)
            {
                head = ne[head];
                continue;
            }
            remove(k);
        }
    }
    
    for (int i = head; i != -1; i = ne[i])
    {
        cout << e[i] << " ";
    }
    
    return 0;
}
```
## AcWing 827. 双链表
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<string>
using namespace std;

int n;
int k, x;
const int N = 100010;
int e[N], l[N], r[N], idx;

void init()
{
	r[0] = 1;
	l[1] = 0;
	idx = 2;
}

void insert_k(int k, int x)
{
	e[idx] = x;
	l[idx] = k;
	r[idx] = r[k];
	l[r[k]] = idx;
	r[k] = idx ++;
}

void remove(int k)
{
	l[r[k]] = l[k];
	r[l[k]] = r[k];
}

int main(void)
{
    ios::sync_with_stdio(false);
	init();
	cin >> n;
	string op;
	while (n --)
	{
		cin >> op;
		if (op == "R")
		{
			cin >> x;
			insert_k(l[1], x);
		}
		else if (op == "D")
		{
			cin >> k;
			remove(k + 1);
		}
		else if (op == "L")
		{
			cin >> x;
			insert_k(0, x);
		}
		else if (op == "IL")
		{
			cin >> k >> x;
			insert_k(l[k + 1], x);
		}
		else
		{
			cin >> k >> x;
			insert_k(k + 1, x);
		}
	}
	
// 	for (int i = 0; i < idx; i ++)
// 	{
// 		cout << e[i] << " ";
// 	}
// 	cout << endl;
// 	for (int i = 0; i < idx; i ++)
// 	{
// 		cout << r[i] << " ";
// 	}
	
	for (int i = r[0]; i != 1; i = r[i])
	{
		cout << e[i] << " ";
	}
	return 0;
}
```


## AcWing 828. 模拟栈
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<string>
using namespace std;

int n;
const int N = 100010;
int st[N], top;

void push(int x)
{
	st[++ top] = x;
}

void pop()
{
	top --;
}

bool empty()
{
	if (top)	return false;
	else	return true;
}

int query()
{
	return st[top];
}

int main(void)
{
    ios::sync_with_stdio(false);
	cin >> n;
	int x;
	string s;
	while (n --)
	{
		cin >> s;
		if (s == "push")
		{
			cin >> x; 
			push(x);
		}
		else if(s == "pop")
		{
			pop();
		}
		else if(s == "empty")
		{
			if (empty())	printf("YES\n");
			else	printf("NO\n");
		}
		else
		{
			printf("%d\n", query());
		}
	}
	return 0;
}
```
## AcWing 829. 模拟队列
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<string>
using namespace std;

int n;
const int N = 100010;
int hh, tt, e[N], q[N];
string s;
int x;

void init()
{
	hh = 0, tt = -1;
}

void push(int x)
{
	q[++ tt] = x;
}

bool empty()
{
	if (hh <= tt)	return false;
	else	return true;
}

int query()
{
	return q[hh];
}

void pop()
{
	hh ++;
}

int main(void)
{
	ios::sync_with_stdio(false);
	init();
	cin >> n;
	while (n --)
	{
		cin >> s;
		if(s == "push")
		{
			cin >> x;
			push(x);
		}
		else if (s == "empty")
		{
			if (empty())	cout << "YES" << endl;
			else	cout << "NO" << endl;
		}
		else if (s == "query")
		{
			cout << query() << endl;
		}
		else
		{
			pop();
		}
	}
	return 0;
}
```

## AcWing 830. 单调栈
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;

int n;
const int N = 100010;
int st[N], tt;

int main(void)
{
	ios::sync_with_stdio(false);
	cin >> n;
	for (int i = 1; i <= n; i ++)
	{
		int x;
		cin >> x;
		while (st[tt] >= x)
		{
			tt --;
		}
		if (tt == 0)	cout << -1 << " ";
		else	cout << st[tt] << " ";
		st[++ tt] = x;
	}
	
	return 0;
}
```

## AcWing 154. 滑动窗口

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;

int n, k;
const int N = 1000010;
int a[N], q[N], hh, tt;

int main(void)
{
	ios::sync_with_stdio(false);
	cin >> n >> k;
	for (int i = 0; i < n; i ++)	cin >> a[i];
	
	hh = 0, tt = -1;
	for (int i = 0; i < n; i ++)
	{
		if (q[hh] < i - k + 1) hh ++;
		while (hh <= tt && a[q[tt]] >= a[i]) tt --;
		q[++ tt] = i;
		if (i >= k - 1)	cout << a[q[hh]] << " ";
	}
	cout << endl;
	hh = 0, tt = -1;
	for (int i = 0; i < n; i ++)
	{
		if (q[hh] < i - k + 1) hh ++;
		while (hh <= tt && a[q[tt]] <= a[i]) tt --;
		q[++ tt] = i;
		if (i >= k - 1)	cout << a[q[hh]] << " ";
	}
	return 0;
}
```