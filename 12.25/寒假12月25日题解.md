## AcWing 799. 最长连续不重复子序列
注意外层for, 内层while的双指针写法.
以及本题中判断重复元素的思想(另设数组, 移动j, 即左起点, 来维护序列)

## AcWing 800. 数组元素的目标和
虽然过了, 但是循环内并没有判断j是否>=0, 可能与答案一定存在有关. 之后为了应对更多更复杂的情况应该加上这条判断

## AcWing 2816. 判断子序列
时间复杂度为O(m+n)

## AcWing 802. 区间和
本题对初学者来说却是不好理解, 需要反复理解各个变量和数组的作用
首先, a[]数组储存的是离散化后的数据, s[]数组是a[]数组的前缀和数组
其次, alls[]数组的作用是储存所有输入数据中出现过的离散化前的位置, 由于我们进行了n次插入操作(每次插入代表一个位置), 和m次询问操作(每次询问代表左端点和右端点两个位置), 因此我们需要3N的数组大小, 才能保证这些位置可以全部存下(这里是理解这道题的关键)
最后的两个数组, add[]和query[]是用来储存之前进行过的插入和询问操作, 方便于在离散化之后进行后续操作)

之后我们首先读入各种数据, 然后就是把接收到的数据进行离散化. 离散化的操作包括排序和去重两部分, 执行完这两步之后alls数组内所储存的就是所有出现过的位置值了, 然后alls的下标就是离散化后的产物

再之后我们进行插入操作, 将插入数据对应到离散化后的数组中. 这里要注意,原下标和离散化后的下标之间的联系是通过alls数组来建立的, 而实现的方法就是二分, 返回结果是alls中原位置当前所在的下标, 也就是离散化后对应的下标, 用这个下标值就可以在a中正常插入数据了. 之后构造前缀和数组没什么好多说的.

最后询问操作与插入操作原理相同, 不再赘述.

学习到的点在于:
1. unique函数的使用
2. for循环中使用迭代器, 用auto item的这种形式, 很方便
3. 复习巩固二分\pair\前缀和的用法
4. 重头戏当然在于离散化思想的学习理解

虽说是一道模板题, 但是还是值得认真思考的
另外，本题当然可以使用map或hash的方法来实现，等明天复习hash表的时候可以来重新做一遍这道题

## AcWing 803. 区间合并
加深学习pair的使用方法
首先, pair的定义是pair<Type,Type>的形式, 为了方便起见, 采用typedef的方式定义为PII
之后, 用这个类型定义的变量均含有两个成分, 分别用.first和.second来访问

本题区间合并的思想是体现在排序后, 后一区间的左端点必定大于等于前一区间的左端点, 这样就只需讨论三种情况: 包含, 跨越, 不包含. 根据不同的情况, 动态维护结果答案和区间右侧端点即可

重新做这类题还是很顺利的，重点还是端点判断的思想

## AcWing 826. 单链表
## AcWing 827. 双链表
这两道题放在一起说。
首先，单链表的实现过程中是使用一个变量head来表示头指针，而用-1代表链表结束的标志；而双链表是把头指针和结束位置储存到了l和r数组中：用下标为0的位置表示头结点，用下标为1的位置表示尾结点。
其次，注意二者元素的存储位置，由于这两道题都是要询问第k个插入的数据，因此这些数据的位置分别是从下标为0和下标为2的位置开始的（很离谱），虽说可以把二者整理成熟悉的下标为1的位置开始，但是这样存储的原因是可以简化操作。
最后需要注意的是这种用数组区域开辟结点地址，再用另外一个数组来链接这些结点下标的思想，包括后面的树和图的存储、Trie树、最短路算法中使用的都是这个思想。
同时有了这个思想，再进行适当的针对不同题目的调整，例如洛谷P1160 队列安排的这道题就需要在插入和删除时进行额外的调整操作。
*最后说一句！在做某些链表题的时候一定要记得初始化！*

## AcWing 828. 模拟栈
## AcWing 829. 模拟队列
同样把这两个数据结构放在一起，虽说如此，但这两个数据结构确实很简单了，复习一遍为了之后对图论、搜索等算法进行栈与队列的优化。

## AcWing 830. 单调栈
单调栈的典型例题之 -- 查找一串数字前比当前位置小的第一个数（或比它大）
代码实现类似双指针，栈内元素为单调的，较好理解。

## AcWing 154. 滑动窗口
单调队列经典例题，第一次见到这题是在《算法竞赛进阶指南》中，是本学期训练中的一道题，当时确实理解起来较为困难。现在做出来还是很顺利的。
我们可以发现, 单调栈和单调队列的应用都是类似双指针算法的样子. 也就是我们在大的数组中遍历时, 要随时更新栈/队列中的元素, 保证其符合一定的单调性.
本题最难理解的部分在于if (q[hh] < i - k + 1) hh ++; 这里, 本题特殊之处在于队列中保存的是坐标位置, 而队列中元素是单调递增的, 因此队头元素保证是最小的那一个, 而当该坐标比当前扫描的位置减去窗口大小(再+1)还要小的时候, 就是该坐标出队的时候
而这些基本的操作是一方面，更为重要的个人认为是如下两点：
1. 队列中不保存元素，而保存坐标，方便模拟“窗口滑动”操作
2. 既然是自己手动模拟队列，那就可以~~不按自然法则来操作队列~~ 不只是从队尾进行插入，从队首进行删除。同样可以从队尾进行删除，而这正是理解好单调队列的实现的最为重要的一点。同时也体现出数组模拟相比于STL除了时间以外的，灵活性上的优势。