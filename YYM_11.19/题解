<UTF-8>
11/19
姚一鸣终于完成了第二个星期的简单题
这是他每个题的解题思路
洛谷P1162填充颜色
    他首先考虑了bfs
        从地图边界某一个不是墙的点进行bfs，//此处有bug
        并把走过的地方都直接在地图中赋值为-1，
        输出时遇0输出2，遇1输出1，遇-1输出0；
    但他想到了一个问题，
        万一有的点遍历不到怎么办
        例如：  000000001111111
                000000001000001
                000000001000001
                111111111000001
                100000000000001
                100000000000111
                111111111111100
        最右下角和最左上角只能有一个被遍历到
    所以他另辟蹊径，想了一个愚蠢至极的办法
        从上向下一行一行地涂色
        对于每一行，从左往右走遇见-1开始涂，遇到1只走不涂
        同样在从右往左走一遍
        再从上往下将上一行的颜色拉下来
        （上一行是-1且下一行是0的下一行改为-1）
        结果发现有这样一个问题：
        000000000
        011111110
        010000010
        010111010
        011101110
        最底下正中间的零涂不到
        于是他有反向进行了上述操作即从下往上拉取颜色
        测试通过
    这时他突然想起应该对图中边界每一个不是墙的点进行bfs，效果应该会更好
    结论：上课的内容非常重要，听错一点就会造成巨大影响，损失惨重
HDU1559最大子矩阵
    直接考虑前缀和
    进行分类讨论左上角arr[0][0],上arr[0][i],左arr[j][0],右下[i][j]
    分别计算，虽然代码量长，但电脑速度应该会有提升，并且好想，不用考虑边界问题
    某一块子矩阵的所有元素之和为其右下角的前缀和减去右上角外侧前缀和减去左下角外侧前缀和加上左上角外侧前缀和
    测试通过
洛谷P1303高精度乘法
    将数字由两字符串保存
    字符串每个字符-'0'
    计算每位乘积放在第三个字符串中（int）
    （这样每一位上存的数都不是只有个位数，还有下一位的个位数的一部分 如123 包含了这一位的3，下一位的2，下下位的1）
    将第三个字符串中每一元素进位
    进位方法：
        只要这一位还有位可进，就把这一位%10播洒进下一位，这一位/=10
    测试通过
    其他收获：
        反转字符串的函数在洛谷不能用：strrev（）
        学到了strlen（最一开始没想起来，用的二分法找'\0'）
洛谷P2249
    二分法，背就完了(最一开始尝试了自己写二分法，超时了，还是背管用)
其他收获：（test-log.cpp）
    复习了union，发现union还是没啥用
    无界double的大小比较永远为假，其与别的数加减乘除结果都是自己
    无界double也永远都不等于自己0x7ffffffff8000000的double与0x7ffffffff8000000的double不相等
    无界double表示为0x7ffffffff8000000(通过union取得此值)
    log(负数)返回值为无界double
    NaN可能在math.h中定义过
    printf无界double会出现 1.#QNAN0