## AcWing 849. Dijkstra求最短路 I
朴素dijkstra算法
找最近点, 用这个点更新其余所有点的最短距离
该算法用来解决固定起点到固定终点的稠密图的最短路问题
注意有无重边和自环的情况下, 输入的区别

## AcWing 850. Dijkstra求最短路 II
dijkstra的堆优化版本
使用了stl自带的priority_queue来帮助实现堆, dijkstra算法中使用的是小顶堆, 故写法如代码所示
注意点在于:
1. 堆优化版本适用于稀疏图, 因此需要使用邻接表来存储图
2. 同时注意邻接表的数组表示法, 知道其中h,e,ne,w,idx分别代表什么
3. 本题使用优先队列时, 队列中元素使用的是pair, 目的是让存入的数据的第一个元素为其距离值, 这样优先队列就会自动帮助排好序. 如果只存点, 将会变得比较麻烦(和朴素dijkstra类似)
4. 朴素dijkstra适用稠密图, 堆优化dijkstra适用稀疏图, 二者均处理没有负权边的情况, 只是适用条件不同, 没有优劣之分.~~ (都不如SPFA)~~

## AcWing 853. 有边数限制的最短路
bellman_ford算法, 用于求带有负权边的, 执行k步可达的, 单源最短路问题
算法思路较为简单
注意的点:
1. 时间复杂度稳定为O(nm)
2. 每次更新各个点的最短距离时, 要使用上一状态, 因此需要用memcpy进行备份
3. 由于每次必须遍历所有边, 因此只需要定义一个结构体来储存所有边的信息即可, 无需邻接矩阵或邻接表的形式

## AcWing 851. spfa求最短路
~~几乎~~万能的spfa算法
用于解决含有负权边的单源最短路问题, 只要不含负权回路都可以使用这个算法
注意的点:
1. 时间复杂度一般为O(m), 最坏为O(nm)
2. 借助队列实现, 一般来说效率比bellman_ford, dijkstra都要高
3. 代码实现与dijkstra类似, 采用邻接表的形式

## AcWing 852. spfa判断负环
spfa判断负环, 具体利用了抽屉原理

## AcWing 854. Floyd求最短路
基于动态规划来实现的floyd算法, 用于解决多源最短路问题
时间复杂度O(n3), 实现较为简单, 只需要注意存图时重边的判断即可

## CODEFORCES 1469A. Regular Bracket Sequence
坑点比较多的一道水题, 需要考虑清楚左右括号和?的前后关系
最后采用前后分别扫描一遍, 不考虑问号的位置解决的这个问题

## CODEFORCES 1469B. Red and Blue
水题, 求两个数组的最大前缀和, 相加即为最终结果

## CODEFORCES 1469C. Building a Fence
算是动态规划的一道题?
或者贪心也可以, 总之就是动态维护一个最高点和一个最低点, 判断后续地面的高度是否在这个范围内, 再用后续高度更新新的最高点和最低点
注意最边的特殊情况即可
