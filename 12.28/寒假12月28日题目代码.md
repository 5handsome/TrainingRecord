## AcWing 849. Dijkstra求最短路 I
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;

const int N = 510;
int g[N][N];
int n, m;
int dist[N];
bool st[N];

int dijkstra()
{
    memset(dist, 0x3f, sizeof(dist));
    dist[1] = 0;
    
    for (int i = 1; i < n; i ++)    //对除n以外的n-1个点进行遍历
    {
        int t = -1;
        for (int j = 1; j <= n; j ++)       //循环n次找到当前状态下距离点1最近的点
        {
            if (!st[j] && (t == -1 || dist[j] < dist[t]))
            {
                t = j;
            }
        }
        if (t == n) break;                  //找到的最近点为n, 符合条件, 跳出
        if (dist[t] == 0x3f3f3f3f)  break;  //找到的最近点距离为无穷, 无可行路径, 跳出
        
        st[t] = true; 
        for (int j = 1; j <= n; j ++)       //用找到的最近点t, 来更新其余所有点可通过点t到达的最近距离
        {
            dist[j] = min(dist[j], dist[t] + g[t][j]);
        }
    }
    
    if (dist[n] == 0x3f3f3f3f)  return -1;
    return dist[n];
}

int main(void)
{
    memset(g, 0x3f, sizeof(g));
    
    cin >> n >> m;
    while (m --)
    {
        int x, y, z;
        scanf("%d%d%d", &x, &y, &z);
        g[x][y] = min(g[x][y], z);
    }
    
    printf("%d", dijkstra());
    
    return 0;
}
```

## AcWing 850. Dijkstra求最短路 II
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<queue>
using namespace std;

typedef pair<int, int> PII;

int n, m;
const int N = 150010;
const int INF = 0x3f3f3f3f;
int h[N], e[N], ne[N], w[N], idx;
int dist[N];
bool st[N];
priority_queue<PII, vector<PII>, greater<PII>> heap;

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;
}

int dijkstra()
{
    dist[1] = 0;
    heap.push({0, 1});
    
    while (heap.size())
    {
        auto t = heap.top();
        heap.pop();
        
        int ver = t.second;
        if (ver == n || dist[ver] == INF)   break;
        if (st[ver])    continue;
        st[ver] = true;
        
        for (int i = h[ver]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[ver] + w[i])
            {
                dist[j] = dist[ver] + w[i];
                heap.push({dist[j], j});
            }
        }
    }
    
    if (dist[n] == INF) return -1;
    return dist[n];
}

int main(void)
{
    cin >> n >> m;
    memset(h, -1, sizeof(h));
    memset(dist, 0x3f, sizeof(dist));
    
    while (m --)
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c);
    }
    
    printf("%d\n", dijkstra());
    
    return 0;
}
```
## AcWing 853. 有边数限制的最短路
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;

const int N = 510, M = 10010;
const int INF = 0x3f3f3f3f;
struct Edges{
    int a, b, w;
}edges[M];      //用于存储所有边的信息

int n, m, k;
int dist[N], last[N];   //last用于表示上一状态

void bellman_ford()
{
    memset(dist, 0x3f, sizeof(dist));
    dist[1] = 0;
    
    for (int i = 1; i <= k; i ++)   //执行k步
    {
        memcpy(last, dist, sizeof(dist));   //备份上一状态
        for (int j = 1; j <= m; j ++)   //遍历所有边, 更新所有边的出边距离
        {
            auto e = edges[j];
            dist[e.b] = min(dist[e.b], last[e.a] + e.w);
        }
    }
}

int main(void)
{
    cin >> n >> m >> k;
    for (int i = 1; i <= m; i ++)
    {
        int a, b, w;
        scanf("%d%d%d", &a, &b, &w);
        edges[i] = {a, b, w};
    }
    
    bellman_ford();
    
    if (dist[n] > INF / 2)  puts("impossible");
    else    printf("%d\n", dist[n]);
    
    return 0;
}
```

## AcWing 851. spfa求最短路

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<queue>
using namespace std;

const int N = 100010;
const int INF = 0x3f3f3f3f;

int h[N], e[N], w[N], ne[N], idx;
int dist[N];
bool st[N];
int n, m;

void add(int a, int b, int c)
{
    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++;
}

void spfa()
{
    memset(dist, 0x3f, sizeof(dist));
    dist[1] = 0;
    
    queue<int> q;
    q.push(1);
    
    while (q.size())
    {
        int t = q.front();
        q.pop();
        
        st[t] = false;
        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                if (!st[j])
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }
}

int main(void)
{
    memset(h, -1, sizeof(h));
    cin >> n >> m;
    while (m --)
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c);
    }
    
    spfa();
    
    if (dist[n] == INF) puts("impossible");
    else    printf("%d\n", dist[n]);
    
    return 0;
}
```

## AcWing 852. spfa判断负环

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<queue>
using namespace std;

const int N = 100010;
const int INF = 0x3f3f3f3f;

int n, m;
int h[N], e[N], ne[N], w[N], idx;
int dist[N], cnt[N];
bool st[N];

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;
}

bool spfa()
{
    queue<int> q;
    for (int i = 1; i <= n; i ++)
    {
        q.push(i);
        st[i] = true;
    }
    
    while (q.size())
    {
        int t = q.front();
        q.pop();
        st[t] = false;
        
        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                cnt[j] = cnt[t] + 1;
                if (cnt[j] == n)    return true;
                if (!st[j])
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }
    
    return false;
}

int main(void)
{
    memset(h, -1, sizeof(h));
    cin >> n >> m;
    while (m --)
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c);
    }
    
    if (spfa()) puts("Yes");
    else    puts("No");
    
    return 0;
}
```

## AcWing 854. Floyd求最短路
```cpp
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<cstring>
using namespace std;

const int N = 210, INF = 0x3f3f3f3f;
int n, m, k;
int d[N][N];

void floyd()
{
    for (int k = 1; k <= n; k ++)
        for (int i = 1; i <= n; i ++)
            for (int j = 1; j <= n; j ++)  
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
}

int main(void)
{
    cin >> n >> m >> k;
    
    for (int i = 1; i <= n; i ++)
        for (int j = 1; j <= n; j ++)
            if (i == j) d[i][j] = 0;
            else    d[i][j] = INF;
    
    while (m --)
    {
        int a, b, w;
        scanf("%d%d%d", &a, &b, &w);
        d[a][b] = min(d[a][b], w);
    }
    
    floyd();
    
    while (k --)
    {
        int a, b;
        scanf("%d%d", &a, &b);
        if (d[a][b] > INF / 2)  puts("impossible");
        else    printf("%d\n", d[a][b]);
    }
    
    return 0;
}
```

## CODEFORCES 1469A. Regular Bracket Sequence
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<string>
using namespace std;

int t;
string s;
int st[1010];
int tt;

int main(void)
{
	cin >> t;
	while (t --)
	{
		cin >> s;
		if (s.size() % 2)
		{
			printf("NO\n");
			continue;
		}
		else
		{
			tt = 0;
			int flag = 1;
			for (int i = 0; i < s.size() && flag; i ++)
			{
				if (s[i] == ')')
				{
					if (tt)
					{
						tt --;
					}
					else
					{
						flag = 0;
						break;
					}
				}
				else
				{
					tt ++;
				}
			}
			
			tt = 0;
			for (int i = s.size() - 1; i >= 0; i --)
			{
				if (s[i] == '(')
				{
					if (tt)
					{
						tt --;
					}
					else
					{
						flag = 0;
						break;
					}
				}
				else
				{
					tt ++;
				}
			}
			
			if (flag)	printf("YES\n");
			else	printf("NO\n");
		}
	}
	
	return 0;
}
```

## CODEFORCES 1469B. Red and Blue
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;

int t;
int n, m;

int main(void)
{
	cin >> t;
	while (t --)
	{
		int a[110] = {0}, b[110] = {0};
		int sa[110] = {0}, sb[110] = {0};
		scanf("%d", &n);
		for (int i = 1; i <= n; i ++)
		{
			scanf("%d", &a[i]);
			sa[i] = sa[i - 1] + a[i];
		}
		scanf("%d", &m);
		for (int i = 1; i <= m; i ++)
		{
			scanf("%d", &b[i]);
			sb[i] = sb[i - 1] + b[i];
		}
		
		int maxa = 0, maxb = 0, maxs = 0;
		for (int i = 1; i <= n; i ++)
		{
			maxa = max(maxa, sa[i]);
		}
		for (int i = 1; i <= m; i ++)
		{
			maxb = max(maxb, sb[i]);
		}
		
		maxs = max(maxs, maxa+maxb);
		printf("%d\n", maxs);
		
	}
	
	return 0;
}
```

## CODEFORCES 1469C. Building a Fence
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
typedef long long ll;

int t;
int n, k;
const int N = 200010;
const ll INF = (ll)1e8+10;
ll a[N];

int main(void)
{
	cin >> t;
	while (t --)
	{
		int flag = 1;
		scanf("%d%d", &n, &k);
		for (int i = 0; i < n; i ++)
		{
			scanf("%lld", &a[i]);
		}
		
		ll h = a[0] + k, l = a[0];
		for (int i = 1; i < n; i ++)
		{
			if (i == n - 1)
			{
				if (a[i]>= l - k + 1 && a[i] <= h - 1)
				{
					flag = 1;
				}
				else	flag = 0;
				break;
			}
			if (a[i] + k - 1 >= l - k + 1 && a[i] <= h - 1)
			{
				h = min(a[i] + k - 1 + k, h + k - 1);
				h = min(INF, h);
				l = max(a[i], l - k + 1);
			}
			else
			{
				flag = 0;
				break;
			}
		}
		
		if (flag)	printf("YES\n");
		else	printf("NO\n");
	}
	
	return 0;
}
```